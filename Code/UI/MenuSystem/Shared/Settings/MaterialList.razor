@namespace Softsplit.UI

<root style=@($"flex-direction: column; font-size: {FontSize}px; width: 100%; height: 100%; overflow-y: scroll;")>
    @foreach(MatData mD in GetMaterials())
    {
        <div style="width:100px; height:100px">
            <ScenePanel  @ref=mD.panel />
        </div>
    }
</root>

@code
{
    public float FontSize {get;set;}
    public string Search {get;set;} = "";
    bool update;

	public List<MatData> GetMaterials()
    {
        List<string> materialSearch;

        if(Search != "") materialSearch = FindCloseMatches(FileSystem.Mounted.FindFile( "materials", "*.vmat_c", true ).ToList(), Search, 2);
        else materialSearch = FileSystem.Mounted.FindFile( "materials", "*.vmat_c", true ).ToList();
        
        List<MatData> MatDatas = new List<MatData>();
            
        foreach(string s in materialSearch)
        {
            MatData newMat = new MatData();
            SceneWorld world = new SceneWorld();
            SceneModel model = new SceneModel( world, "models/dev/plane.vmdl", Transform.Zero);
            //model.SetMaterialOverride( Material.Load(s) );
            Log.Info(Material.Load(s).ResourcePath);

            newMat.panel = new ScenePanel();

            newMat.panel.World = world;
            newMat.panel.Camera.FitModel( model );
            newMat.panel.Camera.BackgroundColor = Color.Transparent;
            newMat.panel.Camera.Angles = new Angles( 20, 180 + 45, 0 );
            newMat.panel.Camera.FieldOfView = 30.0f;
            newMat.panel.Camera.ZFar = 15000.0f;
            newMat.panel.Camera.AmbientLightColor = Color.White * 0.05f;
            newMat.panel.RenderOnce = true;
            MatDatas.Add(newMat);
        }

        Log.Info(MatDatas.Count);
        return MatDatas;
    }

    public class MatData
    {
        public ScenePanel panel;
        public String Path;
    }

    public static List<string> FindCloseMatches(List<string> list, string searchPrompt, int maxDistance)
    {
        List<string> closeMatches = new List<string>();

        foreach (string item in list)
        {
            if (CalculateLevenshteinDistance(item, searchPrompt) <= maxDistance)
            {
                closeMatches.Add(item);
            }
        }

        return closeMatches;
    }

    private static int CalculateLevenshteinDistance(string source, string target)
    {
        if (string.IsNullOrEmpty(source)) return target.Length;
        if (string.IsNullOrEmpty(target)) return source.Length;

        int sourceLength = source.Length;
        int targetLength = target.Length;

        int[,] distance = new int[sourceLength + 1, targetLength + 1];

        for (int i = 0; i <= sourceLength; i++)
            distance[i, 0] = i;

        for (int j = 0; j <= targetLength; j++)
            distance[0, j] = j;

        for (int i = 1; i <= sourceLength; i++)
        {
            for (int j = 1; j <= targetLength; j++)
            {
                int cost = (target[j - 1] == source[i - 1]) ? 0 : 1;

                distance[i, j] = Math.Min(
                    Math.Min(distance[i - 1, j] + 1, distance[i, j - 1] + 1),
                    distance[i - 1, j - 1] + cost);
            }
        }

        return distance[sourceLength, targetLength];
    }

    protected override int BuildHash() => System.HashCode.Combine( update );
}